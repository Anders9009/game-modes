/**
 * Rules for the Elite mode
 */

#Extends "Modes/ShootMania/ModeSport.Script.txt"

#Const Version		"2013-05-15"
#Const ScriptName	"Elite.Script.txt"

#Include "Libs/Nadeo/Settings.Script.txt" as Settings
#Include "Libs/Nadeo/ShootMania/Draft.Script.txt" as Draft
#Include "Libs/Nadeo/ShootMania/KingOfTheLobby.Script.txt" as Lobby
#Include "Libs/Nadeo/ShootMania/WeaponSelection.Script.txt" as WeaponSelection
#Include "Libs/Nadeo/ShootMania/ScoresTable.Script.txt" as ScoresTable	///< Fix: The lobby can't work without including this lib in Elite

#Setting S_TurnWin				6		as _("Number of points to win a map")					///< Score to reach to win a map
#Setting S_UseDraft				False	as _("Use draft mode before match")						///< Use draft mode at match beginning
#Setting S_DraftBanNb			4		as _("Number of map to ban during draft (-1: ban all)")	///< Number of map to ban during draft
#Setting S_DraftPickNb			3		as _("Number of map to pick during draft")				///< Number of map to pick during draft
#Setting S_UseEliteB2			False	as _("Elite Beta 2 gameplay")							///< Use the beta 2 gameplay settings
#Const S_ForceWeaponSelection	True	// as _("Force the use of the local setting for weapons selection")
#Setting S_UseWeaponSelection	False	as _("Allow defenders to select their weapons")	
#Setting S_DisplayLaser			True	as _("Display the defenders with Laser through walls")	
#Setting S_UseLobby				False	as "<hidden>" // _("Launch server in lobby mode")
#Setting S_LobbyTimePerMap		86400	as "<hidden>" // _("Time limit in lobby mode (sec., 0: no limit)")

#Const S_Use3vs3Mode			False	//as _("Play on 3vs3 mode")

#Const C_AtkRocketAmmoMax	4	///< Atk Rocket ammo max
#Const C_AtkRocketAmmoGain	1.	///< Atk Rocket ammo gain
#Const C_AtkLaserAmmoMax	1	///< Atk Laser ammo max
#Const C_AtkLaserAmmoGain	1.	///< Atk Laser ammo gain
#Const C_AtkNucleusAmmoMax	1	///< Atk Nucleus ammo max
#Const C_AtkNucleusAmmoGain	1.	///< Atk Nucleus ammo gain

#Const C_DefRocketAmmoMax	4	///< Def Rocket ammo max
#Const C_DefRocketAmmoGain	1.	///< Def Rocket ammo gain
#Const C_DefLaserAmmoMax	1	///< Def Laser ammo max
#Const C_DefLaserAmmoGain	0.65///< Def Laser ammo gain
#Const C_DefNucleusAmmoMax	1	///< Def Nucleus ammo max
#Const C_DefNucleusAmmoGain	0.75	///< Def Nucleus ammo gain

#Const C_WeaponSelectionDuration		5000	///< Time for the defenders to select their weapons
#Const C_DefRocketStaminaMaxMultiplier	0.7		///< Stamina amount multiplier for the defense
#Const C_DefLaserStaminaMaxMultiplier	0.9		///< Stamina amount multiplier for the defense
#Const C_DefNucleusStaminaMaxMultiplier	0.5		///< Stamina amount multiplier for the defense

#Const C_DefRocketAmmoGainMalus		1.	///< Team ammo gain malus if a defender select the Rocket
#Const C_DefLaserAmmoGainMalus		0.8	///< Team ammo gain malus if a defender select the Laser
#Const C_DefNucleusAmmoGainMalus	1.	///< Team ammo gain malus if a defender select the Nucleus

#Const C_DefRocketStaminaMalus	1.	///< Team stamina malus if a defender select the Rocket
#Const C_DefLaserStaminaMalus	0.8	///< Team stamina malus if a defender select the Laser
#Const C_DefNucleusStaminaMalus	1.	///< Team stamina malus if a defender select the Nucleus

#Const C_3vs3_AtkNbMax					3		///< Number of attacker spawned at the start of the round
#Const C_3vs3_AtkArmorMax				100		///< Number of armor at spawn for the attackers
#Const C_3vs3_AtkLaserAmmoMax			1		///< Number of Laser ammo for the attackers
#Const C_3vs3_AtkLaserAmmoGain			1.		///< Reload speed of the Laser for the attackers
#Const C_3vs3_AtkStaminaMaxMultiplier	1.		///< Stamina amount multiplier for the attackers
#Const C_3vs3_EliminationOnPass			False	///< Eliminate the player who initiate the pass
#Const C_3vs3_PassOnElimination			True	///< Pass the Laser when the current holder is eliminated
#Const C_3vs3_TimeBeforePassActivation	20000	///< Time before the attackers can do pass

#Const C_RequiredPlayersNb	3	///< Required number of players in each team

// ---------------------------------- //
// Online settings
#Const C_SettingsUrl			"http://files.maniaplanet.com/scriptsettings/Elite.ScriptSettings.xml"

#Const C_OAtkRocketAmmoMax		"1"	///< Atk Rocket ammo max
#Const C_OAtkRocketAmmoGain		"2"	///< Atk Rocket ammo gain
#Const C_OAtkLaserAmmoMax		"3"	///< Atk Laser ammo max
#Const C_OAtkLaserAmmoGain		"4"	///< Atk Laser ammo gain
#Const C_OAtkNucleusAmmoMax		"5"	///< Atk Nucleus ammo max
#Const C_OAtkNucleusAmmoGain	"6"	///< Atk Nucleus ammo gain

#Const C_ODefRocketAmmoMax		"7"	///< Def Rocket ammo max
#Const C_ODefRocketAmmoGain		"8"	///< Def Rocket ammo gain
#Const C_ODefLaserAmmoMax		"9"	///< Def Laser ammo max
#Const C_ODefLaserAmmoGain		"10"	///< Def Laser ammo gain
#Const C_ODefNucleusAmmoMax		"11"	///< Def Nucleus ammo max
#Const C_ODefNucleusAmmoGain	"12"	///< Def Nucleus ammo gain

#Const C_OWeaponSelectionDuration			"13"	///< Time for the defenders to select their weapons
#Const C_ODefRocketStaminaMaxMultiplier		"14"	///< Stamina amount multiplier for the defense
#Const C_ODefLaserStaminaMaxMultiplier		"15"	///< Stamina amount multiplier for the defense
#Const C_ODefNucleusStaminaMaxMultiplier	"16"	///< Stamina amount multiplier for the defense

#Const C_ODefStaminaMaxMultiplier	"17"	///< Stamina amount multiplier for the defense
#Const C_OAtkStaminaMaxMultiplier	"18"	///< Stamina amount multiplier for the attack

#Const C_ODefRocketStaminaMalus		"19"	///< Time before the respawn of a Rocket defender
#Const C_ODefLaserStaminaMalus		"20"	///< Time before the respawn of a Laser defender
#Const C_ODefNucleusStaminaMalus	"21"	///< Time before the respawn of a Nucleus defender

#Const C_ODefRocketAmmoGainMalus	"22"	///< Team ammo gain malus if a defender select the Rocket
#Const C_ODefLaserAmmoGainMalus		"23"	///< Team ammo gain malus if a defender select the Laser
#Const C_ODefNucleusAmmoGainMalus	"24"	///< Team ammo gain malus if a defender select the Nucleus

#Const C_OUseWeaponSelection		"25"	///< Allow defenders to choose their weapons

#Const Description _("TYPE: Team versus Team (1 vs 3)\nOBJECTIVE:\nOne attacker plays against three defenders. The attacker must capture the pole or eliminate the defenders. The defenders must eliminate the attacker or prevent him to capture the pole.\nThe attacker uses the Laser while the defenders have the Rocket.\nThe first team to reach the points limit wins the map.")


declare Integer G_CheckpointsCapturedNb;	///< Number of captured checkpoints

***LogVersion***
***
MB_LogVersion(ScriptName, Version);
MB_LogVersion(Draft::GetScriptName(), Draft::GetScriptVersion());
MB_LogVersion(Settings::GetScriptName(), Settings::GetScriptVersion());
MB_LogVersion(Lobby::GetScriptName(), Lobby::GetScriptVersion());
MB_LogVersion(WeaponSelection::GetScriptName(), WeaponSelection::GetScriptVersion());
***

***Rules***
***
// ---------------------------------- //
// Create rules
declare ModeName = "Elite";
declare ModeRules = TextLib::Compose(
	_("Two teams - 1 vs 3\n\n- The defenders must eliminate the attacker or prevent him from capturing the pole.\n- The attacker has to eliminate all defenders or capture the pole between %1 seconds and %2 seconds.\n- The game is divided in rounds of two turns each.\n- During a round each team play one turn in attack and one turn in defense.\n- The team in defense play with 3 players using rockets.\n- The team in attack play with 1 player using laser.\n- The team who wins the turn scores 1 point.\n- The first team to score at least %3 points with %4 ahead of his opponent wins the map."),
	TextLib::ToText(S_TimeLimit - S_TimePole),
	TextLib::ToText(S_TimeLimit),
	TextLib::ToText(S_TurnWin),
	TextLib::ToText(S_TurnGap)
);
SpawnScreen::CreateRules(ModeName, ModeRules);
ModeStatusMessage = _("TYPE: Team versus Team (1 vs 3)\nOBJECTIVE: Capture the pole when you're the attacker. Defend the pole when you're a defender.");
***

***StartServer***
***
// ---------------------------------- //
// Lobby mode
// Change map once a day
if (S_UseLobby) Lobby::StartLobbyMode(S_LobbyTimePerMap, True);

// ---------------------------------- //
// Init
declare LayerInfoId	= Layers::Create("Info");
Draft::StartServer();
Settings::Load();

// ---------------------------------- //
// Load settings
if (!S_UseEliteB2 || (S_ForceWeaponSelection && S_UseWeaponSelection) || !S_ForceWeaponSelection) {
	declare Loaded = Settings::LoadFromUrl(C_SettingsUrl);
	if (Loaded) MB_Log("Successfully loaded online settings");
	else MB_Log("Failed to load online settings, use local values instead");
}

G_UseEliteB2 = S_UseEliteB2;
if (S_ForceWeaponSelection) {
	G_UseWeaponSelection = S_UseWeaponSelection;
} else {
	G_UseWeaponSelection = Settings::GetBoolean(C_OUseWeaponSelection, S_UseWeaponSelection);
}
G_DisplayLaser = S_DisplayLaser;

// ---------------------------------- //
// Weapon choice
if (G_UseWeaponSelection) {
	WeaponSelection::Load();
	G_InitDefHit = [1 => 0, 2 => 0, 3 => 0];
	G_DefMarkers = [CSmMode::EWeapon::Rocket => Text[Ident], CSmMode::EWeapon::Laser => Text[Ident], CSmMode::EWeapon::Nucleus => Text[Ident]];
	G_DefLayerMarkers = [CSmMode::EWeapon::Rocket => Text[Ident], CSmMode::EWeapon::Laser => Text[Ident], CSmMode::EWeapon::Nucleus => Text[Ident]];
	
	declare LayerPlayerMarkersId = Layers::Create("PlayerMarkers");
	declare LayerSpecMarkersId = Layers::Create("SpecMarkers");
	Layers::GetFromId(LayerPlayerMarkersId).Type = CUILayer::EUILayerType::Markers;
	Layers::GetFromId(LayerSpecMarkersId).Type = CUILayer::EUILayerType::Markers;
}

if (G_UseEliteB2) {
	GameplayVersion		= 1;
	UseAmmoBonusOnHit	= False;
} else {
	GameplayVersion		= 0;
	UseAmmoBonusOnHit	= True;
}

// ---------------------------------- //
// 3vs3 mode
if (S_Use3vs3Mode) G_Use3vs3Mode = True;
else G_Use3vs3Mode = False;
***

***StartMatch***
***
declare MapPlayedSinceMatchBeginning = 0;	///< Even maps skipped by a vote
if (S_UseDraft && (S_Mode == 0 || S_Mode == 1)) {
	Mode::LoadMap();
	
	G_TieBreakDefElim = [1 => 0, 2 => 0];
	G_AtkClan = 1;
	G_DefClan = 2;
	Clan1Score = 0;
	Clan2Score = 0;
	Users_SetNbFakeUsers(C_BlueBotsNb, C_RedBotsNb);
	
	// ---------------------------------- //
	// Initialize UI
	UIManager.ResetAll();
	InitUi();
	SpawnScreen::AttachRules();
	LayerAttached = Layers::Attach("ScoresTable", NullId);
	LayerAttached = Layers::Attach("PlayersLists", NullId);
	
	// ---------------------------------- //
	// Reset the attack order
	WarmUp::ResetOrder();
	DoWarmUp();
	
	LayerDetached = Layers::Detach("ScoresTable", NullId);
	LayerDetached = Layers::Detach("PlayersLists", NullId);
	
	declare Order = WarmUp::GetOrder();
	declare Selected = [1 => Ident[], 2 => Ident[]];
	for (I, 1, 2) {
		foreach (PlayerId => PlayerOrder in Order[I]) {
			Selected[I].add(PlayerId);
		}
	}
	Draft::SetPlayersSelected(Selected);
	TossWinner = Toss::Toss();
	Draft::MapSelection(S_DraftBanNb, S_DraftPickNb, TossWinner);
	
	declare TmpNextMapIndex = Draft::GetMapIndex(1);
	if (TmpNextMapIndex >= 0) NextMapIndex = TmpNextMapIndex;
	
	Mode::UnloadMap();
}
***

***StartMap***
***
LayerAttached = Layers::Attach("Info", NullId);
UseLaserVsBullets = True;
***

***StartTurn***
***
G_CheckpointsCapturedNb = 0;

LayerAttached = Layers::Attach("Info", NullId);
LayerUpdated = Layers::Update("Info", UpdateLayerInfo(False));
***

***SelectNextMap***
***
MapPlayedSinceMatchBeginning += 1;
if (S_UseDraft && (S_Mode == 0 || S_Mode == 1)) {
	declare TmpNextMapIndex = Draft::GetMapIndex(MapPlayedSinceMatchBeginning + 1);
	if (TmpNextMapIndex >= 0) NextMapIndex = TmpNextMapIndex;
}
***

***EndServer***
***
LayerDestroyed = Layers::Destroy("Info");
Draft::EndServer();
Settings::Unload();

// ---------------------------------- //
// Weapon choice
if (G_UseWeaponSelection) {
	WeaponSelection::Unload();
	LayerDestroyed = Layers::Destroy("PlayerMarkers");
	LayerDestroyed = Layers::Destroy("SpecMarkers");
}
***

***SpawnDef***
***
if (DefSpawned >= MaxDef) break;
if (!Players.existskey(PlayerId)) continue;
declare Player <=> Players[PlayerId];

SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, Settings::GetInteger(C_ODefRocketAmmoMax, C_DefRocketAmmoMax));
SetPlayerAmmoMax(Player, CSmMode::EWeapon::Laser, Settings::GetInteger(C_ODefLaserAmmoMax, C_DefLaserAmmoMax));
SetPlayerAmmoMax(Player, CSmMode::EWeapon::Nucleus, Settings::GetInteger(C_ODefNucleusAmmoMax, C_DefNucleusAmmoMax));

declare DefWeapon	= CSmMode::EWeapon::Rocket;
Player.AmmoGain		= Settings::GetReal(C_ODefRocketAmmoGain, C_DefRocketAmmoGain);
Player.StaminaMax	= Settings::GetReal(C_ODefStaminaMaxMultiplier, C_DefStaminaMaxMultiplier);
Player.StaminaGain	= Settings::GetReal(C_ODefStaminaMaxMultiplier, C_DefStaminaMaxMultiplier);
Player.ArmorMax		= C_DefArmorMax;
+++SetDefParameters+++
SetPlayerWeapon(Player, DefWeapon, True);
SM::SpawnPlayer(Player, G_DefClan, Player.ArmorMax, DefBlockSpawn, Now);
SetPlayerAmmo(Player, CSmMode::EWeapon::Nucleus, Settings::GetInteger(C_ODefNucleusAmmoMax, C_DefNucleusAmmoMax));
Player.IsHighlighted = True;
DefSpawned += 1;
***

***SpawnAtk***
***
if (G_Use3vs3Mode) MaxAtk = C_3vs3_AtkNbMax;
if (AtkSpawned >= MaxAtk) break;
if (!Players.existskey(PlayerId)) continue;			
declare Player <=> Players[PlayerId];

SetPlayerAmmoMax(Player, CSmMode::EWeapon::Rocket, Settings::GetInteger(C_OAtkRocketAmmoMax, C_AtkRocketAmmoMax));
SetPlayerAmmoMax(Player, CSmMode::EWeapon::Laser, Settings::GetInteger(C_OAtkLaserAmmoMax, C_AtkLaserAmmoMax));
SetPlayerAmmoMax(Player, CSmMode::EWeapon::Nucleus, Settings::GetInteger(C_OAtkNucleusAmmoMax, C_AtkNucleusAmmoMax));

Player.AmmoGain		= Settings::GetReal(C_OAtkLaserAmmoGain, C_AtkLaserAmmoGain);
Player.StaminaMax	= Settings::GetReal(C_OAtkStaminaMaxMultiplier, C_AtkStaminaMaxMultiplier);
Player.StaminaGain	= Settings::GetReal(C_OAtkStaminaMaxMultiplier, C_AtkStaminaMaxMultiplier);

if (S_Mode == 1) Player.ArmorMax = DefSpawned * 100;
else Player.ArmorMax = C_AtkArmorMax;
if (Player.ArmorMax < 100) Player.ArmorMax = 100;

if (G_Use3vs3Mode) {
	Player.StaminaMax	= C_3vs3_AtkStaminaMaxMultiplier;
	Player.StaminaGain	= C_3vs3_AtkStaminaMaxMultiplier;
	Player.ArmorMax		= C_3vs3_AtkArmorMax;
	SetPlayerAmmoMax(Player, CSmMode::EWeapon::Laser, C_3vs3_AtkLaserAmmoMax);
}

SetPlayerWeapon(Player, CSmMode::EWeapon::Laser, False); 
SM::SpawnPlayer(Player, G_AtkClan, Player.ArmorMax, AtkBlockSpawn, Now);
SetPlayerAmmo(Player, CSmMode::EWeapon::Nucleus, Settings::GetInteger(C_OAtkNucleusAmmoMax, C_AtkNucleusAmmoMax));
Player.IsHighlighted = True;
if (G_Use3vs3Mode) {
	if (AtkSpawned == 0) {
		Player.AmmoGain = C_3vs3_AtkLaserAmmoGain;
		SetPlayerAmmo(Player, CSmMode::EWeapon::Laser, C_3vs3_AtkLaserAmmoMax);
		Player.IsHighlighted = True;
		G_AtkPlayerId = PlayerId;
	} else {
		Player.AmmoGain = 0.;
		SetPlayerAmmo(Player, CSmMode::EWeapon::Laser, 0);
		Player.IsHighlighted = False;
	}
} else {
	G_AtkPlayerId = PlayerId;
}
AtkSpawned += 1;
***

***PoleManagement***
***
if (Now >= PoleTime) {
	// ---------------------------------- //
	// When the goal can be captured
	if (!GoalCanBeCaptured) {
		GoalCanBeCaptured = True;
		UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::PhaseChange;
		UIManager.UIAll.BigMessageSoundVariant = 0;
		UIManager.UIAll.BigMessage = _("The goal can now be captured.");
		UIManager.UIAll.CountdownEndTime = -1;
	}
	
	// ---------------------------------- //
	// Check if the attacker is capturing the pole
	foreach (Goal in Goals) {		
		if (Goal.Gauge.Value == 0 && Goal.Gauge.Clan == G_DefClan) {
			Goal.Gauge.Clan = G_AtkClan;
			// Set the Max value depending on the number of checkpoints in the map
			if (Checkpoints.count <= 0) {
				Goal.Gauge.Max = MathLib::NearestInteger(S_TimeCapture * 1000) * BlockPoles.count;
			} else {
				// + 1 in order to see the gauge filled (With a Max of 0 the gauge can't be filled)
				Goal.Gauge.Max = ((Checkpoints.count - G_CheckpointsCapturedNb) * 1000) + 500;
			}
		}
		
		if (Goal.Sector.PlayersIds.exists(G_AtkPlayerId)) {
			if(Goal.Gauge.Clan == G_DefClan) {
				Goal.Gauge.Speed = -1;
			} else {
				Goal.Gauge.Speed = 1;
				if (Players.existskey(G_AtkPlayerId) && Goal.Gauge.ValueReal < 1.) {
					declare UI <=> UIManager.GetUI(Players[G_AtkPlayerId]);
					if (UI != Null) {
						UI.GaugeRatio = Goal.Gauge.ValueReal;
						UI.GaugeMessage = MathLib::FloorInteger(Goal.Gauge.ValueReal * 100)^"%";
						UI.GaugeClan = Players[G_AtkPlayerId].CurrentClan;
					}
				}
			}
		} else {
			if (Players.existskey(G_AtkPlayerId)) {
				declare UI <=> UIManager.GetUI(Players[G_AtkPlayerId]);
				if (UI != Null) {
					Goal.Gauge.Speed = 0;
					UI.GaugeRatio = -1.;
					UI.GaugeMessage = "";
					UI.GaugeClan = 0;
				}
			}
		}
	}
} else {
	// ---------------------------------- //
	// Monitor the checkpoints
	foreach (Checkpoint in Checkpoints) {
		if (Checkpoint.Captured) continue;
		
		if (Checkpoint.Sector.PlayersIds.exists(G_AtkPlayerId)) {
			Checkpoint.Gauge.Speed = 1000;
		}
	}
}	
***

***EventOnHit***
***
// ---------------------------------- //
// Pass the Laser to another attacker
if (G_Use3vs3Mode && StartTime + C_3vs3_TimeBeforePassActivation <= Now && Event.Shooter.CurrentClan == Event.Victim.CurrentClan && Event.Shooter.CurrentClan == G_AtkClan) {
	Event.Damage = 0;
	G_AtkPlayerId = Event.Victim.Id;
	
	Event.Victim.AmmoGain = C_3vs3_AtkLaserAmmoGain;
	SetPlayerAmmo(Event.Victim, CSmMode::EWeapon::Laser, C_3vs3_AtkLaserAmmoMax);
	Event.Victim.IsHighlighted = True;

	Event.Shooter.AmmoGain = 0.;
	SetPlayerAmmo(Event.Shooter, CSmMode::EWeapon::Laser, 0);
	Event.Shooter.IsHighlighted = False;
	
	if (C_3vs3_EliminationOnPass) Event.Shooter.Armor = 0;
		
	PassOn(Event);
} else if (Event.Shooter.CurrentClan == Event.Victim.CurrentClan) {
	Discard(Event);
} else {
	Event.Damage = 100;
	if (Players.existskey(G_AtkPlayerId)) {
		// ---------------------------------- //
		// Shooter is in atk clan, victim in def clan
		if (Event.Shooter.Id == G_AtkPlayerId) {
			if (LastActionClanNb != G_AtkClan) SoundVariant += 1;
			LastActionClanNb = G_AtkClan;
			
			// Elim last defenders
			if (ClansNbPlayersAlive[G_DefClan] <= 1) {
				PlaySound(CUIConfig::EUISound::VictoryPoint, 0);
			} 
			// Elim standard defenders
			else {
				PlaySound(CUIConfig::EUISound::TieBreakPoint, SoundVariant);
			}
			
			if (ClansNbPlayersAlive[G_DefClan] > 1) {
				declare DefLeft = ClansNbPlayersAlive[G_DefClan] - 1;
				if (DefLeft <= 1) {
					Message::SendStatusMessage(
						TextLib::Compose(
							"%1%2", 
							Teams[G_DefClan - 1].ColorText,
							_("1 defender left.")
						), 3000, 2
					);
				} else {
					Message::SendStatusMessage(
						TextLib::Compose(
							_("%1 %2 defenders left."), 
							Teams[G_DefClan - 1].ColorText, 
							TextLib::ToText(DefLeft)
						), 3000, 2
					);
				}
				LastStatusTime = Now;
			}
			
			DisplayHitDistance(Event.Shooter, Event.Victim, False);
			if (Event.Shooter.Score != Null && Event.Victim != Null) {
				declare LaserLongest for Event.Shooter.Score = 0.;
				declare LaserHit for Event.Shooter.Score = 0;
				declare Distance = MathLib::Distance(Event.Shooter.Position, Event.Victim.Position);
				if (Distance > LaserLongest) LaserLongest = Distance;
				LaserHit += 1;
			}
		} 
		// ---------------------------------- //
		// Shooter is in def clan, victim in atk clan
		else {
			if (LastActionClanNb != G_DefClan) SoundVariant += 1;
			LastActionClanNb = G_DefClan;
			
			// Pass the Laser
			if (C_3vs3_PassOnElimination && Players[G_AtkPlayerId].Armor <= 100 && Event.Victim.Id == G_AtkPlayerId) {
				foreach (Player in Players) {
					if (Player.CurrentClan == G_AtkClan && Player.Id != G_AtkPlayerId && Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) {
						G_AtkPlayerId = Player.Id;
	
						Player.AmmoGain = C_3vs3_AtkLaserAmmoGain;
						SetPlayerAmmo(Player, CSmMode::EWeapon::Laser, C_3vs3_AtkLaserAmmoMax);
						Player.IsHighlighted = True;
						break;
					}
				}
			}
			
			// Elim attacker
			if (Players[G_AtkPlayerId].Armor <= 100 && Event.Victim.Id == G_AtkPlayerId) {
				PlaySound(CUIConfig::EUISound::VictoryPoint, 0);
				AtkIsEliminated = True;	///< Set atk elimination at the frame of the hit, not the next OnArmorEmpty
			} 
			// Hit attacker
			else {
				PlaySound(CUIConfig::EUISound::TiePoint, SoundVariant);
			}
			
			if (Players[G_AtkPlayerId].Armor > 100) {
				declare ArmorLeft = (Players[G_AtkPlayerId].Armor - 100) / 100;
				if (ArmorLeft <= 1) {
					Message::SendStatusMessage(
						TextLib::Compose(
							"%1%2", Teams[G_AtkClan - 1].ColorText, _("1 armor left.")
						), 3000, 2
					);
				} else {
					Message::SendStatusMessage(
						TextLib::Compose(
							_("%1 %2 armors left."), 
							Teams[G_AtkClan - 1].ColorText, 
							TextLib::ToText(ArmorLeft)
						), 3000, 2
					);
				}
				LastStatusTime = Now;
			}
			
			if (Event.Shooter.Score != Null) {
				declare NbHit for Event.Shooter.Score = 0;
				NbHit += 1;
			}
			
			LayerUpdated = Layers::Update("Info", UpdateLayerInfo(True));
		}
	}
	
	+++EventOnHitExp+++
	UpdateLayerScoresTable(C_SequencePlaying);
	
	// Stats
	declare JSON = Json::Enfold(EliteStringify("Event", Event));
	if (MB_UseScriptCallbacks) XmlRpc.SendCallback("OnHit", JSON);
	
	// Don't forget to send stats for the atk elimination because we won't trigger the OnArmorEmpty event
	if (AtkIsEliminated) {
		declare JSON2 = Json::Enfold(EliteStringifySimulateArmorEmpty("Event", Event));
		if (MB_UseScriptCallbacks) XmlRpc.SendCallback("OnArmorEmpty", JSON2);
		G_AtkElimPlayerId = Event.Shooter.Id;
	}
	
	PassOn(Event);
}
***

***EventOnArmorEmpty***
***
if (Event.Shooter != Null && Event.Shooter.CurrentClan == G_AtkClan) {
	G_MatchDefElim[Event.Shooter.CurrentClan] += 1;
	G_MapDefElim[Event.Shooter.CurrentClan] += 1;
	if (G_TieBreak) G_TieBreakDefElim[Event.Shooter.CurrentClan] += 1;
	UpdateLayerScoresTable(C_SequencePlaying);
}

// Stats
declare JSON = Json::Enfold(EliteStringify("Event", Event));
if (MB_UseScriptCallbacks) XmlRpc.SendCallback("OnArmorEmpty", JSON);

+++EventOnArmorEmptyExp+++

PassOn(Event);
***

***EventOnPlayerRequestRespawn***
***
// Stats
declare JSON = Json::Enfold(EliteStringify("Event", Event));
if (MB_UseScriptCallbacks) XmlRpc.SendCallback("OnPlayerRequestRespawn", JSON);

+++EventOnPlayerRequestRespawnExp+++

PassOn(Event);
***

***EventOnCapture***
***
if (AtkIsEliminated) {
	Discard(Event);
} else {
	if (Event.BlockPole.Tag == "Checkpoint") {
		G_CheckpointsCapturedNb += 1;
		// If the pole can already be captured, update its max value here
		if (Now >= PoleTime) {
			foreach (Goal in Goals) {
				Goal.Gauge.Max = ((Checkpoints.count - G_CheckpointsCapturedNb) * 1000) + 1;
			}
		}
		
		UIManager.UIAll.SendNotice(
			_("Checkpoint captured."), CUIConfig::ENoticeLevel::MatchInfo, 
			Null, CUIConfig::EAvatarVariant::Default, 
			CUIConfig::EUISound::Capture, 0
		);
		
		LayerUpdated = Layers::Update("Info", UpdateLayerInfo(False));
		//UpdateMarkers();
	} else if (Event.BlockPole.Tag == "Goal A" || Event.BlockPole.Tag == "Goal B" || Event.BlockPole.Tag == "Goal C") {
		UIManager.UIAll.SendNotice(
			"", CUIConfig::ENoticeLevel::MatchInfo, 
			Null, CUIConfig::EAvatarVariant::Default, 
			CUIConfig::EUISound::Capture, 0
		);
	}
	
	// Stats
	declare JSON = Json::Enfold(EliteStringify("Event", Event));
	if (MB_UseScriptCallbacks) XmlRpc.SendCallback("OnCapture", JSON);

	PassOn(Event);
}
***

***EventOnShoot***
***
if (
	Event.Shooter != Null 
	&& Event.Shooter.Id == G_AtkPlayerId 
	&& Event.Shooter.Score != Null
	&& Event.WeaponNum == C_WeaponLaser
) {
	declare LaserShot for Event.Shooter.Score = 0;
	LaserShot += 1;
	UpdateLayerScoresTable(C_SequencePlaying);
}

// Stats
declare JSON = Json::Enfold(EliteStringify("Event", Event));
if (MB_UseScriptCallbacks) XmlRpc.SendCallback("OnShoot", JSON);

PassOn(Event);
***

***EventOnNearMiss***
***
declare MaxMissDist = 0.5;
if (Event.Shooter != Null && Event.Victim != Null) {
	declare Distance = MathLib::Distance(Event.Shooter.Position, Event.Victim.Position);
	MaxMissDist = Distance * 2 / 100;
	if (MaxMissDist > 0.5) MaxMissDist = 0.5;
}

if (Event.Shooter.CurrentClan == G_AtkClan && Event.MissDist <= MaxMissDist) {
	if (Event.MissDist < 0.01) {
		Message::SendStatusMessage(
			TextLib::Compose(
				_("%1$<%2$> misses by %3cm."), 
				Teams[G_AtkClan - 1].ColorText,
				Event.Shooter.Name, 
				TextLib::ToText(1)
			), 3000, 2
		);
	} else {
		Message::SendStatusMessage(
			TextLib::Compose(
				_("%1$<%2$> misses by %3cm."), 
				Teams[G_AtkClan - 1].ColorText,
				Event.Shooter.Name, 
				TextLib::ToText(MathLib::CeilingInteger(Event.MissDist*100))
			), 3000, 2
		);
	}
	
	// Stats
	declare JSON = Json::Enfold(EliteStringify("Event", Event));
	if (MB_UseScriptCallbacks) XmlRpc.SendCallback("OnNearMiss", JSON);
	
	PassOn(Event);
} else {
	Discard(Event);
}
***

***EndTurnUIStart***
***
LayerUpdated = Layers::Update("Info", UpdateLayerInfo(False));

UIManager.UIAll.Hud3dMarkers = "";
if (G_UseWeaponSelection && G_DisplayLaser) {
	LayerDetached = Layers::Detach("PlayerMarkers", NullId);
	LayerDetached = Layers::Detach("SpecMarkers", NullId);
	LayerUpdated = Layers::Update("Markers", "");
	G_DefMarkers[CSmMode::EWeapon::Rocket].clear();
	G_DefMarkers[CSmMode::EWeapon::Laser].clear();
	G_DefMarkers[CSmMode::EWeapon::Nucleus].clear();
	G_DefLayerMarkers[CSmMode::EWeapon::Rocket].clear();
	G_DefLayerMarkers[CSmMode::EWeapon::Laser].clear();
	G_DefLayerMarkers[CSmMode::EWeapon::Nucleus].clear();
}
***

***EndTurnUIStop***
***
LayerDetached = Layers::Detach("Info", NullId);
***

***CreateLayerScoresTable***
***
declare CW = 1.;
declare SW = 1.;

declare Team1Color = """{{{Teams[0].ColorPrimary.X}}} {{{Teams[0].ColorPrimary.Y}}} {{{Teams[0].ColorPrimary.Z}}}""";
declare Team2Color = """{{{Teams[1].ColorPrimary.X}}} {{{Teams[1].ColorPrimary.Y}}} {{{Teams[1].ColorPrimary.Z}}}""";
	
return """
<quad posn="0 -0.5 -1" sizen="237 90" halign="center" valign="center" image="file://Media/Manialinks/ShootMania/Elite/interface_elite_bg.dds" />
<quad posn="-73.2 11 6" sizen="29 44.3" halign="center" valign="center" image="file://Media/Manialinks/ShootMania/Elite/interface_elite_left.dds" colorize="{{{Team1Color}}}" />
<quad posn=" 73.2 11 6" sizen="29 44.3" halign="center" valign="center" image="file://Media/Manialinks/ShootMania/Elite/interface_elite_right.dds" colorize="{{{Team2Color}}}" />

<!--<quad posn="-150 90" sizen="{{{50*CW}}} 20" halign="left" valign="top" style="TitleLogos" substyle="Title"/>-->
	
<!-- **************** Scores table **************** -->
<frame posn="0 34" id ="Frame_ScoresTable">
	<!-- **************** Center panel **************** -->
	<frame posn="0 0">		
		<!-- **************** VS **************** -->
		<frame posn="0 -11.7" id="Frame_VS">
			<quad posn="-7 -2.5" sizen="15 15" halign="right" valign="bottom" style="Emblems" substyle="#1" />
			<quad posn="7 -2.5" sizen="15 15" valign="bottom" style="Emblems" substyle="#2" />
			<label posn="-46 1.5" sizen="46 5" textsize="4" halign="center" valign="bottom" scale="0.95" opacity="0.88" textemboss="1" id="Label_NameTeam1" />
			<label posn=" 46 1.5" sizen="46 5" textsize="4" halign="center" valign="bottom" scale="0.95" opacity="0.88" textemboss="1" id="Label_NameTeam2" />
		</frame>
		<!-- **************** Players Ranking **************** -->
		<frame posn="{{{-164*CW/2.}}} -16" id="Frame_Ranking">
			{{{CreatePlayersListBig(1, C_RequiredPlayersNb*2, CW)}}}
		</frame>
	</frame>	
	<!-- **************** Bottom panels **************** -->
	<frame posn="{{{-164*CW/2.}}} -47">
		<!-- **************** Laser stats **************** -->
		<quad posn="{{{1*SW}}} -8.2" sizen="4 4" halign="left" valign="center" image="file://Media/Manialinks/ShootMania/Common/Laser.dds" />
		<label posn="{{{6*SW}}} -8" sizen="{{{75*SW}}} 6" textsize="2" textcolor="{{{C_UI_Colors["Text"]}}}" valign="center" textemboss="1" text="{{{TextLib::Compose(_("Longest Laser: %1 by %2"), "-", "-")}}}" id="Label_LongestLaser" />
		<!-- **************** Server info **************** -->
		<label posn="{{{158*CW}}} -8" sizen="{{{75*SW}}} 5" textsize="2" textcolor="{{{C_UI_Colors["Text"]}}}" halign="right" valign="center" textemboss="1" text="{{{TextLib::Compose("%1: $<%2$>", _("Server"), "-")}}}" id="Label_ServerName" />
		<quad posn="{{{163*SW}}} -8.2" sizen="4 4" halign="right" valign="center" image="file://Media/Manialinks/ShootMania/Common/Home.dds" />
		<!-- **************** Game info **************** -->
		<quad posn="{{{0.7*SW}}} -13.7" sizen="5 5" halign="left" valign="center" style="UIConstructionSimple_Buttons" substyle="Tools" />
		<label posn="{{{6*SW}}} -13.5" sizen="{{{75*SW}}} 6" textsize="2" textcolor="{{{C_UI_Colors["Text"]}}}" valign="center" textemboss="1" text="{{{TextLib::Compose(_("Points limit: %1 | Points to win: %2"), "6", "8")}}}" id="Label_GameInfo" />
		<label posn="{{{158*CW}}} -13.5" sizen="{{{75*SW}}} 5" textsize="2" textcolor="{{{C_UI_Colors["Text"]}}}" halign="right" valign="center" textemboss="1" text="{{{TextLib::Compose(_("Turns won: %1 - %2 | Eliminations: %3 - %4"), "0", "0","0", "0")}}}" id="Label_GoalAverage" />
		<quad posn="{{{163*SW}}} -13.7" sizen="4 4" halign="right" valign="center" image="file://Media/Manialinks/ShootMania/Common/Score.dds" />
	</frame>
</frame>
<script><!--
#Include "TextLib" as TextLib

declare CMlLabel	Label_NameTeam1;
declare CMlLabel 	Label_NameTeam2;
declare CMlFrame	Frame_Ranking;
declare CMlLabel	Label_LongestLaser;
declare CMlLabel	Label_ServerName;
declare CMlLabel	Label_GameInfo;
declare CMlLabel	Label_GoalAverage;

Void UpdatePlayersList(
	Integer				_AttackerKey, 
	Text[Integer]		_Logins, 
	Text[Integer]		_Names, 
	Text[Integer]		_Zones,
	Integer[Integer]	_Ranks,
	Real[Integer]		_LadderPoints,
	Boolean[Integer]	_Ready,
	Integer[Integer]	_DefPoints, 
	Integer[Integer]	_AtkPoints,
	Integer				_Mode,
	Integer[Integer][Integer] _DefHit,
	Integer[Integer]	_Fames,
	Ident[Integer]		_PlayersIds
) {	
	for (I, 1, {{{C_RequiredPlayersNb*2}}}) {
		declare Frame_Player	<=> (Frame_Ranking.GetFirstChild("Frame_Player_"^I) as CMlFrame);
		
		if (_Logins.existskey(I)) {
			declare Quad_NotReady			<=> (Frame_Player.GetFirstChild("Quad_NotReady")			as CMlQuad);
			declare Quad_Ready				<=> (Frame_Player.GetFirstChild("Quad_Ready")				as CMlQuad);
			declare Quad_Avatar 			<=> (Frame_Player.GetFirstChild("Quad_Avatar")				as CMlQuad);
			declare Quad_Eliminated			<=> (Frame_Player.GetFirstChild("Quad_Eliminated")			as CMlQuad);
			declare Label_Name				<=> (Frame_Player.GetFirstChild("Label_Name")				as CMlLabel);
			declare Label_Rank				<=> (Frame_Player.GetFirstChild("Label_Rank")				as CMlLabel);
			declare Frame_Stars				<=> (Frame_Player.GetFirstChild("Frame_Stars")				as CMlFrame);
			declare Label_DefPoints			<=> (Frame_Player.GetFirstChild("Label_DefPoints")			as CMlLabel);
			declare Label_AtkPoints			<=> (Frame_Player.GetFirstChild("Label_AtkPoints")			as CMlLabel);
			declare Quad_Attacker			<=> (Frame_Player.GetFirstChild("Quad_Attacker")			as CMlQuad);
			declare Frame_LadderPoints		<=> (Frame_Player.GetFirstChild("Frame_LadderPoints")		as CMlFrame);
			declare Label_LadderPoints		<=> (Frame_Player.GetFirstChild("Label_LadderPoints")		as CMlLabel);
			declare Frame_DefPointsSimple	<=> (Frame_Player.GetFirstChild("Frame_DefPointsSimple")	as CMlFrame);
			declare Frame_DefPointsDetailed	<=> (Frame_Player.GetFirstChild("Frame_DefPointsDetailed")	as CMlFrame);
			declare Label_DefLaser			<=> (Frame_DefPointsDetailed.GetFirstChild("Label_DefLaser")	as CMlLabel);
			declare Label_DefRocket			<=> (Frame_DefPointsDetailed.GetFirstChild("Label_DefRocket")	as CMlLabel);
			declare Label_DefNucleus		<=> (Frame_DefPointsDetailed.GetFirstChild("Label_DefNucleus")	as CMlLabel);
			
			declare Side = 1;
			if (Label_Name.PosnX < 0) Side = -1;
			
			Frame_Player.Show();
			// Ready state
			if (_Mode == {{{C_SequenceWarmUp}}}) {
				Quad_Avatar.PosnX = {{{6 + (3*CW)}}} * Side;
				Label_Name.PosnX = {{{17*CW}}} * Side;
				Label_Rank.PosnX = {{{18*CW}}} * Side;
				Frame_Stars.PosnX = {{{14.6*CW}}} * Side;
				if (_Ready.existskey(I)) {
					if (_Ready[I]) {
						Quad_Ready.Show();
						Quad_NotReady.Hide();
					} else {
						Quad_Ready.Hide();
						Quad_NotReady.Show();
					}
				} else {
					Quad_Ready.Hide();
					Quad_NotReady.Show();
				}
			} else {
				Quad_Avatar.PosnX = {{{6 + (0*CW)}}} * Side;
				Label_Name.PosnX = {{{14*CW}}} * Side;
				Label_Rank.PosnX = {{{15*CW}}} * Side;
				Frame_Stars.PosnX = {{{11.6*CW}}} * Side;
				Quad_Ready.Hide();
				Quad_NotReady.Hide();
			}
			// Avatar
			if (_Logins.existskey(I) && _Names.existskey(I)) {
				Quad_Avatar.ChangeImageUrl("file://Avatars/"^_Logins[I]^"/Default");
			} else {
				Quad_Avatar.ChangeImageUrl("");
			}
			// Status
			/*if (UI.UISequence == CUIConfig::EUISequence::Playing && _PlayersIds.existskey(I)) {
				if (Players.existskey(_PlayersIds[I])) {
					if (Players[_PlayersIds[I]].SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) {
						Quad_Eliminated.Show();
					} else {
						Quad_Eliminated.Hide();
					}
				} else {
					Quad_Eliminated.Hide();
				}
			} else {
				Quad_Eliminated.Hide();
			}*/
			// Name
			if (_Names.existskey(I)) {
				Label_Name.SetText("$s"^_Names[I]);
			} else {
				Label_Name.SetText("$s-");
			}
			// Rank
			if (_Ranks.existskey(I) && _Ranks[I] > 0 && _Zones.existskey(I)) {
				Label_Rank.SetText(TextLib::Compose("%1: %2", _Zones[I], TextLib::ToText(_Ranks[I])));
			} else {
				Label_Rank.SetText(TextLib::Compose("%1: %2", _("Other"), "-"));
			}
			// Stars Fames
			if (_Fames.existskey(I)) {
				declare Fame = _Fames[I];
				if (Fame > 0 && Fame <= 5) {
					declare Quad_Star_1 <=> (Frame_Stars.GetFirstChild("Quad_Star_1") as CMlQuad);
					declare Quad_Star_2 <=> (Frame_Stars.GetFirstChild("Quad_Star_2") as CMlQuad);
					declare Quad_Star_3 <=> (Frame_Stars.GetFirstChild("Quad_Star_3") as CMlQuad);
					declare Quad_Star_4 <=> (Frame_Stars.GetFirstChild("Quad_Star_4") as CMlQuad);
					declare Quad_Star_5 <=> (Frame_Stars.GetFirstChild("Quad_Star_5") as CMlQuad);
					Frame_Stars.Show();
					Quad_Star_1.Hide();
					Quad_Star_2.Hide();
					Quad_Star_3.Hide();
					Quad_Star_4.Hide();
					Quad_Star_5.Hide();
					
					if (Fame >= 1) Quad_Star_1.Show();
					if (Fame >= 2) Quad_Star_2.Show();
					if (Fame >= 3) Quad_Star_3.Show();
					if (Fame >= 4) Quad_Star_4.Show();
					if (Fame >= 5) Quad_Star_5.Show();
				} else {
					Frame_Stars.Hide();
				}
			} else {
				Frame_Stars.Hide();
			}
			// Ladder points
			if (_Mode == {{{C_SequencePodium}}} && _LadderPoints.existskey(I) && _LadderPoints[I] >= 0) {
				declare LadderPointsExplode = TextLib::Split(".", TextLib::ToText(_LadderPoints[I]));
				declare LadderPoints = "0.0";
				if (LadderPointsExplode.existskey(0)) LadderPoints = LadderPointsExplode[0];
				if (LadderPointsExplode.existskey(1)) LadderPoints ^= "."^TextLib::SubString(LadderPointsExplode[1], 0, 2);
			
				Frame_LadderPoints.Show();
				Label_LadderPoints.SetText("$s$bb8+"^LadderPoints);
			} else {
				Frame_LadderPoints.Hide();
			}
			// DefPoints
			if (_DefHit.existskey(I) && _DefHit[I][1] >= 0 && _DefHit[I][3] >= 0) {
				Frame_DefPointsSimple.Hide();
				Frame_DefPointsDetailed.Show();
				if (_DefPoints.existskey(I)) {
					Label_DefLaser.SetText("$s"^_DefHit[I][1]);
					Label_DefRocket.SetText("$s"^_DefHit[I][2]);
					Label_DefNucleus.SetText("$s"^_DefHit[I][3]);
				} else {
					Label_DefLaser.SetText("$s0");
					Label_DefRocket.SetText("$s0");
					Label_DefNucleus.SetText("$s0");
				}
			} else {
				Frame_DefPointsSimple.Show();
				Frame_DefPointsDetailed.Hide();
				if (_DefPoints.existskey(I)) {
					Label_DefPoints.SetText("$s"^_DefPoints[I]);
				} else {
					Label_DefPoints.SetText("$s0");
				}
			}
			// AtkPoints
			if (_AtkPoints.existskey(I)) {
				Label_AtkPoints.SetText("$s"^_AtkPoints[I]);
			} else {
				Label_AtkPoints.SetText("$s0");
			}
			// Attacker
			if (I == _AttackerKey && _Mode == {{{C_SequencePlaying}}}) {
				Quad_Attacker.Show();
			} else {
				Quad_Attacker.Hide();
			}
		} else {
			Frame_Player.Hide();
		}
	}
}

Void UpdateStats(
	Text[Integer]		_Names,
	Real[Integer]		_LaserLongest,
	Integer[Integer]	_LaserHit,
	Integer[Integer]	_LaserShot
) {	
	declare LaserLongest = Real[Integer];
	foreach (Key => Distance in _LaserLongest) {
		if (Distance > 0.) LaserLongest[Key] = Distance * -1.;
	}
	LaserLongest = LaserLongest.sort();
	declare LaserAccuracy = Real[Integer];
	
	foreach (Key => Nb in _LaserShot) {
		if (Nb > 0 && _LaserHit.existskey(Key) && _LaserHit[Key] > 0) {
			LaserAccuracy[Key] = ((_LaserHit[Key] * 1.) / (Nb * 1.)) * -100.;
		}
	}
	LaserAccuracy = LaserAccuracy.sort();
	
	declare Longest = "-";
	declare LongestName = "-";
	declare Accuracy = "-";
	declare AccuracyName = "-";
	
	foreach (Key => Distance in LaserLongest) {
		Longest = TextLib::SubString(TextLib::ToText(Distance*-1.), 0, 5)^"m";
		if (_Names.existskey(Key)) LongestName = "$<"^_Names[Key]^"$>";
		break;
	}
	
	foreach (Key => Percentage in LaserAccuracy) {
		Accuracy = _LaserHit[Key]^"/"^_LaserShot[Key]^" ("^TextLib::SubString(TextLib::ToText(Percentage*-1.), 0, 5)^"%)";
		if (_Names.existskey(Key)) AccuracyName = _Names[Key];
		break;
	}
	
	Label_LongestLaser.SetText(TextLib::Compose(_("Longest Laser: %1 by %2"), Longest, LongestName));
}

Void UpdateGameInfo(
	Integer _PointsLimit,
	Integer _PointsToWin,
	Integer[Integer] _Turns,
	Integer[Integer] _Eliminations
) {
	Label_GameInfo.SetText(TextLib::Compose(_("Points limit: %1 | Points to win: %2"), TextLib::ToText(_PointsLimit), TextLib::ToText(_PointsToWin)));
	
	if (_Eliminations.existskey(1) && _Eliminations.existskey(2)) {
		Label_GoalAverage.SetText(TextLib::Compose(_("Turns won: %1 - %2 | Eliminations: %3 - %4"), TextLib::ToText(_Turns[1]), TextLib::ToText(_Turns[2]), TextLib::ToText(_Eliminations[1]), TextLib::ToText(_Eliminations[2])));
	} else {
		Label_GoalAverage.SetText(TextLib::Compose(_("Turns won: %1 - %2"), TextLib::ToText(_Turns[1]), TextLib::ToText(_Turns[2])));
	}
}

Void UpdatePlayersStatus(Boolean _Forced) {
	declare netread Text[Integer] Net_LayerST_Logins for UI;
	
	foreach (Player in Players) {
		declare PrevSpawnStatus for Player = CSmPlayer::ESpawnStatus::Spawned;
		if (PrevSpawnStatus != Player.SpawnStatus || _Forced) {
			PrevSpawnStatus = Player.SpawnStatus;
			if (!Net_LayerST_Logins.exists(Player.Login)) continue;
			
			declare Frame_Player <=> (Frame_Ranking.GetFirstChild("Frame_Player_"^Net_LayerST_Logins.keyof(Player.Login)) as CMlFrame);
			if (Frame_Player == Null) continue;
			
			declare Quad_Eliminated <=> (Frame_Player.GetFirstChild("Quad_Eliminated") as CMlQuad);
			declare netread Integer Net_LayerST_Mode for UI;
			
			if (Net_LayerST_Mode == {{{C_SequencePlaying}}} && UI.UISequence == CUIConfig::EUISequence::Playing) {
				if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) {
					Quad_Eliminated.Show();
				} else {
					Quad_Eliminated.Hide();
				}
			} else {
				Quad_Eliminated.Hide();
			}
		}
	}
}

main() {
	Label_NameTeam1			<=> (Page.GetFirstChild("Label_NameTeam1")		as CMlLabel);
	Label_NameTeam2			<=> (Page.GetFirstChild("Label_NameTeam2")		as CMlLabel);
	Frame_Ranking			<=> (Page.GetFirstChild("Frame_Ranking")		as CMlFrame);
	Label_LongestLaser		<=> (Page.GetFirstChild("Label_LongestLaser")	as CMlLabel);
	Label_ServerName		<=> (Page.GetFirstChild("Label_ServerName")		as CMlLabel);
	Label_GameInfo			<=> (Page.GetFirstChild("Label_GameInfo")		as CMlLabel);
	Label_GoalAverage		<=> (Page.GetFirstChild("Label_GoalAverage")	as CMlLabel);
	
	declare netread Integer				Net_LayerST_Update			for UI;
	declare netread Integer				Net_LayerST_AttackerKey		for UI;
	declare netread Text[Integer]		Net_LayerST_Logins			for UI;
	declare netread Integer[Integer]	Net_LayerST_AtkPoints		for UI;
	declare netread Integer[Integer]	Net_LayerST_DefPoints		for UI;
	declare netread Real[Integer]		Net_LayerST_LaserLongest	for UI;
	declare netread Integer[Integer]	Net_LayerST_LaserShot		for UI;
	declare netread	Integer[Integer]	Net_LayerST_LaserHit		for UI;
	declare netread Integer				Net_LayerST_PointsLimit		for UI;
	declare netread Integer				Net_LayerST_PointsToWin		for UI;
	declare netread Integer[Integer]	Net_LayerST_Turns			for UI;
	declare netread Integer[Integer]	Net_LayerST_Eliminations	for UI;
	declare netread Boolean[Integer]	Net_LayerST_Ready			for UI;
	declare netread Integer				Net_LayerST_Mode			for UI;
	declare netread Integer[Integer][Integer] Net_LayerST_DefHit	for UI;
	
	declare Text[Integer]		Logins;
	declare Text[Integer]		Names;
	declare Integer[Integer]	LadderRanks;
	declare Text[Integer]		Zones;
	declare Integer				Order;
	declare Real[Integer]		LadderPoints;
	declare Integer[Integer]	Fames;
	declare Ident[Integer]		PlayersIds;
	
	declare LastUpdate = Net_LayerST_Update;
	declare PrevUISequence = CUIConfig::EUISequence::None;
	declare PrevServerName = "";

	while (True) {
		yield;
		
		if (InputPlayer == Null) continue;
		if (!PageIsVisible) continue;
		
		if (PrevServerName != CurrentServerName) {
			PrevServerName = CurrentServerName;
			Label_ServerName.SetText(TextLib::Compose("%1: $<%2$>", _("Server"), CurrentServerName));
		}
		
		if (LastUpdate != Net_LayerST_Update) {
			LastUpdate = Net_LayerST_Update;
			
			UpdatePlayersStatus(True);
			
			if (Teams[0].ColorizedName == "$<$00fBlue$>") Label_NameTeam1.SetText("$<$fffBlue$>");
			else Label_NameTeam1.SetText(Teams[0].ColorizedName);
			if (Teams[1].ColorizedName == "$<$f00Red$>") Label_NameTeam2.SetText("$<$fffRed$>");
			else Label_NameTeam2.SetText(Teams[1].ColorizedName);
			
			Logins = Net_LayerST_Logins;
			
			if (Net_LayerST_AttackerKey <= 0) Order = -1;
			else if (Net_LayerST_AttackerKey <= 3) Order = Net_LayerST_AttackerKey;
			else Order = Net_LayerST_AttackerKey - 3;
			
			Names.clear();
			LadderRanks.clear();
			foreach (Score in Scores) {
				if (Logins.exists(Score.User.Login)) {
					declare Key = Logins.keyof(Score.User.Login);
					Names[Key] = Score.User.Name;
					LadderRanks[Key] = Score.User.LadderRank;
					LadderPoints[Key] = Score.LadderScore;
					Fames[Key] = Score.User.FameStars;
					
					declare ZonePath = "";
					if (Score.User.ZonePath != "") {
						declare ExplodeZonePath = TextLib::Split("|", Score.User.ZonePath);
						if (ExplodeZonePath.existskey(1)) ZonePath = ExplodeZonePath[1];
					}
					Zones[Key] = ZonePath;
				}
			}
			/*foreach (Player in Players) {
				if (Logins.exists(Player.Login)) {
					declare Key = Logins.keyof(Player.Login);
					PlayersIds[Key] = Player.Id;
				}
			}*/
			
			UpdatePlayersList(
				Net_LayerST_AttackerKey, 
				Logins, 
				Names, 
				Zones,
				LadderRanks,
				LadderPoints,
				Net_LayerST_Ready, 
				Net_LayerST_DefPoints, 
				Net_LayerST_AtkPoints,
				Net_LayerST_Mode,
				Net_LayerST_DefHit,
				Fames,
				PlayersIds
			);
			
			UpdateStats(
				Names,
				Net_LayerST_LaserLongest,
				Net_LayerST_LaserHit,
				Net_LayerST_LaserShot
			);
			
			UpdateGameInfo(
				Net_LayerST_PointsLimit,
				Net_LayerST_PointsToWin,
				Net_LayerST_Turns,
				Net_LayerST_Eliminations
			);
		}
		
		if (PrevUISequence != UI.UISequence) {
			PrevUISequence = UI.UISequence;
			
			if (UI.UISequence != CUIConfig::EUISequence::Playing) {
				for (I, 1, {{{C_RequiredPlayersNb*2}}}) {
					declare Frame_Player	<=> (Frame_Ranking.GetFirstChild("Frame_Player_"^I)	as CMlFrame);
					declare Quad_Eliminated <=> (Frame_Player.GetFirstChild("Quad_Eliminated") as CMlQuad);
					Quad_Eliminated.Hide();
				}
			}
		}
		
		if (UI.UISequence == CUIConfig::EUISequence::Playing) UpdatePlayersStatus(False);
	}
}
--></script>
""";
***

***UpdateLayerScoresTable***
***
declare Logins			= Text[Integer];
declare AttackerKey		= -1;
declare AtkPoints		= Integer[Integer];
declare DefPoints		= Integer[Integer];
declare LasersLongest	= Real[Integer];
declare LasersHit		= Integer[Integer];
declare LasersShot		= Integer[Integer];
declare Eliminations	= [0 => 0];
declare ReadyState		= Boolean[Integer];
declare DetailedDefPoints = Integer[Integer][Integer];

for (I, 1, 2) {
	declare J = 1;
	G_MapOrder[I] = G_MapOrder[I].sort();
	foreach (Id => Order in G_MapOrder[I]) {
		if (Players.existskey(Id)) {
			declare Key = J+((I-1)*3);
			declare Player <=> Players[Id];
			Logins[Key] = Player.Login;
			if (Id == G_AtkPlayerId) AttackerKey = Key;
			if (Player.Score != Null) {
				declare NbHit for Player.Score = 0;
				declare LaserLongest for Player.Score = 0.;
				declare LaserHit for Player.Score = 0;
				declare LaserShot for Player.Score = 0;
				declare DefHit for Player.Score = G_InitDefHit;
				AtkPoints[Key] = Player.Score.Points;
				DefPoints[Key] = NbHit;
				LasersLongest[Key] = LaserLongest;
				LasersHit[Key] = LaserHit;
				LasersShot[Key] = LaserShot;
				DetailedDefPoints[Key] = DefHit;
			}
			ReadyState[Key] = WarmUp::IsReady(Player);
		}
		J += 1;
	}
}

if (G_TieBreak) Eliminations = [1 => G_TieBreakDefElim[1], 2 => G_TieBreakDefElim[2]];

declare PlayersAndSpectators = CSmPlayer[];
foreach (Player in Players) PlayersAndSpectators.add(Player);
foreach (Spectator in Spectators) PlayersAndSpectators.add(Spectator);
foreach (Player in PlayersAndSpectators) {
	declare UI <=> UIManager.GetUI(Player);
	if (UI == Null) continue;
	
	declare netwrite Integer			Net_LayerST_Update			for UI;
	declare netwrite Integer			Net_LayerST_AttackerKey		for UI;
	declare netwrite Text[Integer]		Net_LayerST_Logins			for UI;
	declare netwrite Integer[Integer]	Net_LayerST_AtkPoints		for UI;
	declare netwrite Integer[Integer]	Net_LayerST_DefPoints		for UI;
	declare netwrite Real[Integer]		Net_LayerST_LaserLongest	for UI;
	declare netwrite Integer[Integer]	Net_LayerST_LaserShot		for UI;
	declare netwrite Integer[Integer]	Net_LayerST_LaserHit		for UI;
	declare netwrite Integer			Net_LayerST_PointsLimit		for UI;
	declare netwrite Integer			Net_LayerST_PointsToWin		for UI;
	declare netwrite Integer[Integer]	Net_LayerST_Turns			for UI;
	declare netwrite Integer[Integer]	Net_LayerST_Eliminations	for UI;
	declare netwrite Boolean[Integer]	Net_LayerST_Ready			for UI;
	declare netwrite Integer			Net_LayerST_Mode			for UI;
	declare netwrite Integer[Integer][Integer] Net_LayerST_DefHit	for UI;
	
	Net_LayerST_Update			= Now;
	Net_LayerST_AttackerKey		= AttackerKey;
	Net_LayerST_Logins			= Logins;
	Net_LayerST_AtkPoints		= AtkPoints;
	Net_LayerST_DefPoints		= DefPoints;
	Net_LayerST_LaserLongest	= LasersLongest;
	Net_LayerST_LaserShot		= LasersShot;
	Net_LayerST_LaserHit		= LasersHit;
	Net_LayerST_PointsLimit		= S_TurnWin;
	Net_LayerST_PointsToWin		= GetPointLimit();
	Net_LayerST_Turns			= [1 => G_MatchPoints[1], 2 => G_MatchPoints[2]];
	Net_LayerST_Eliminations	= Eliminations;
	Net_LayerST_Ready			= ReadyState;
	Net_LayerST_Mode			= _Mode;
	Net_LayerST_DefHit			= DetailedDefPoints;
}
***


// ---------------------------------- //
// Weapon choice
// ---------------------------------- //
***StartPreTurn***
***
if (G_UseWeaponSelection) {
	PreTurnEndTime = Now + Settings::GetInteger(C_OWeaponSelectionDuration, C_WeaponSelectionDuration);
	declare TurnPlayers = WarmUp::GetOrder();
	declare DefPlayersIds = Ident[];
	foreach (PlayerId => Order in TurnPlayers[G_DefClan]) {
		DefPlayersIds.add(PlayerId);
	}
	WeaponSelection::Start(DefPlayersIds);
}
***

***EndPreTurn***
***
if (G_UseWeaponSelection) {
	MB_Sleep(500);
	WeaponSelection::StopAll();
	
	if (G_DisplayLaser) {
		G_DefMarkers[CSmMode::EWeapon::Rocket].clear();
		G_DefMarkers[CSmMode::EWeapon::Laser].clear();
		G_DefMarkers[CSmMode::EWeapon::Nucleus].clear();
		G_DefLayerMarkers[CSmMode::EWeapon::Rocket].clear();
		G_DefLayerMarkers[CSmMode::EWeapon::Laser].clear();
		G_DefLayerMarkers[CSmMode::EWeapon::Nucleus].clear();
		LayerUpdated = Layers::Update("Markers", "");
	}
	
	G_DefAmmoGainMalus	= 1.;
	G_DefStaminaMalus	= 1.;
	
	declare TurnPlayers = WarmUp::GetOrder();
	foreach (PlayerId => Order in TurnPlayers[G_DefClan]) {
		if (!Players.existskey(PlayerId)) continue;
		
		declare RocketAmmoGainMalus 	= Settings::GetReal(C_ODefRocketAmmoGainMalus, C_DefRocketAmmoGainMalus);
		declare LaserAmmoGainMalus		= Settings::GetReal(C_ODefLaserAmmoGainMalus, C_DefLaserAmmoGainMalus);
		declare NucleusAmmoGainMalus	= Settings::GetReal(C_ODefNucleusAmmoGainMalus, C_DefNucleusAmmoGainMalus);
		
		declare RocketStaminaMalus	= Settings::GetReal(C_ODefRocketStaminaMalus, C_DefRocketStaminaMalus);
		declare LaserStaminaMalus	= Settings::GetReal(C_ODefLaserStaminaMalus, C_DefLaserStaminaMalus);
		declare NucleusStaminaMalus	= Settings::GetReal(C_ODefNucleusStaminaMalus, C_DefNucleusStaminaMalus);
		
		declare Weapon = WeaponSelection::GetWeapon(Players[PlayerId]);
		if (Weapon == CSmMode::EWeapon::Rocket) {
			G_DefAmmoGainMalus	-= (1. - RocketAmmoGainMalus);
			G_DefStaminaMalus	-= (1. - RocketStaminaMalus);
		} else if (Weapon == CSmMode::EWeapon::Laser) {
			G_DefAmmoGainMalus	-= (1. - LaserAmmoGainMalus);
			G_DefStaminaMalus	-= (1. - LaserStaminaMalus);
		} else if (Weapon == CSmMode::EWeapon::Nucleus) {
			G_DefAmmoGainMalus	-= (1. - NucleusAmmoGainMalus);
			G_DefStaminaMalus	-= (1. - NucleusStaminaMalus);
		}
	}
}
***

***SetDefParameters***
***
if (G_UseWeaponSelection) {
	DefWeapon = WeaponSelection::GetWeapon(Player);
	// ---------------------------------- //
	// Rocket
	if (DefWeapon == CSmMode::EWeapon::Rocket) {
		Player.AmmoGain		= Settings::GetReal(C_ODefRocketAmmoGain, C_DefRocketAmmoGain) * G_DefAmmoGainMalus;
		Player.StaminaMax	= Settings::GetReal(C_ODefRocketStaminaMaxMultiplier, C_DefRocketStaminaMaxMultiplier) * G_DefStaminaMalus;
		Player.StaminaGain	= Settings::GetReal(C_ODefRocketStaminaMaxMultiplier, C_DefRocketStaminaMaxMultiplier) * G_DefStaminaMalus;
	} 
	// ---------------------------------- //
	// Laser
	else if (DefWeapon == CSmMode::EWeapon::Laser) {
		Player.AmmoGain		= Settings::GetReal(C_ODefLaserAmmoGain, C_DefLaserAmmoGain) * G_DefAmmoGainMalus;
		Player.StaminaMax	= Settings::GetReal(C_ODefLaserStaminaMaxMultiplier, C_DefLaserStaminaMaxMultiplier) * G_DefStaminaMalus;
		Player.StaminaGain	= Settings::GetReal(C_ODefLaserStaminaMaxMultiplier, C_DefLaserStaminaMaxMultiplier) * G_DefStaminaMalus;
		
		if (G_DisplayLaser) {
			G_DefMarkers[CSmMode::EWeapon::Laser][Player.Id] = """<marker playerlogin="{{{TextLib::MLEncode(Player.Login)}}}" manialinkframeid="Marker_{{{TextLib::MLEncode(Player.Login)}}}" box="0 1.85 0" />""";
			G_DefLayerMarkers[CSmMode::EWeapon::Laser][Player.Id] = """<frame id="Marker_{{{TextLib::MLEncode(Player.Login)}}}"><quad sizen="4 4" halign="center" valign="bottom" image="file://Media/Manialinks/ShootMania/Common/LaserWhite.dds" /></frame>""";
		}
	} 
	// ---------------------------------- //
	// Nucleus
	else if (DefWeapon == CSmMode::EWeapon::Nucleus) {
		Player.AmmoGain		= Settings::GetReal(C_ODefNucleusAmmoGain, C_DefNucleusAmmoGain) * G_DefAmmoGainMalus;
		Player.StaminaMax	= Settings::GetReal(C_ODefNucleusStaminaMaxMultiplier, C_DefNucleusStaminaMaxMultiplier) * G_DefStaminaMalus;
		Player.StaminaGain	= Settings::GetReal(C_ODefNucleusStaminaMaxMultiplier, C_DefNucleusStaminaMaxMultiplier) * G_DefStaminaMalus;
	}
}
***

***UpdateMarkers***
***
if (G_UseWeaponSelection && G_DisplayLaser) {
	declare LayerAttached = Layers::Attach("PlayerMarkers", NullId);
	declare LayerDetached = Layers::Detach("SpecMarkers", NullId);
	
	declare DefMarkers = "";
	declare DefLayerMarkers = "";
	if (G_DefMarkers.existskey(CSmMode::EWeapon::Laser)) {
		foreach (Marker in G_DefMarkers[CSmMode::EWeapon::Laser]) {
			DefMarkers ^= Marker;
		}
	}
	if (G_DefLayerMarkers.existskey(CSmMode::EWeapon::Laser)) {
		foreach (Marker in G_DefLayerMarkers[CSmMode::EWeapon::Laser]) {
			DefLayerMarkers ^= Marker;
		}
	}
	UIManager.UIAll.Hud3dMarkers ^= DefMarkers;
	declare LayerUpdated = Layers::Update("PlayerMarkers", DefLayerMarkers);
}
***

***EventOnHitExp***
***
if (G_UseWeaponSelection) {
	if (Event.Shooter != Null) {
		declare CSmMode::EWeapon Weapon;
		if (Event.WeaponNum == 2) Weapon = CSmMode::EWeapon::Rocket;
		else if (Event.WeaponNum == 1) Weapon = CSmMode::EWeapon::Laser;
		else if (Event.WeaponNum == 3) Weapon = CSmMode::EWeapon::Nucleus;
		
		if (Event.Shooter.Score != Null && Event.Shooter.CurrentClan == G_DefClan) {
			declare DefHit for Event.Shooter.Score = G_InitDefHit;
			if (DefHit.existskey(Event.WeaponNum)) DefHit[Event.WeaponNum] += 1;
		}
	}
}
***

***EventOnArmorEmptyExp***
***
if (G_UseWeaponSelection && G_DisplayLaser) {
	if (
		Event.Victim != Null 
		&& Event.Victim.CurrentClan == G_DefClan 
	) {
		declare Weapon = WeaponSelection::GetWeapon(Event.Victim);
		declare Removed = G_DefMarkers[Weapon].removekey(Event.Victim.Id);
		Removed = G_DefLayerMarkers[Weapon].removekey(Event.Victim.Id);
		+++UpdateMarkers+++
	}
}
***

***EventOnPlayerRequestRespawnExp***
***
if (G_UseWeaponSelection && G_DisplayLaser) {
	if (
		Event.Player != Null 
		&& Event.Player.CurrentClan == G_DefClan
	) {
		declare Weapon = WeaponSelection::GetWeapon(Event.Player);
		declare Removed = G_DefMarkers[Weapon].removekey(Event.Player.Id);
		Removed = G_DefLayerMarkers[Weapon].removekey(Event.Player.Id);
		+++UpdateMarkers+++
	}
}
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
/** Get the info manialink string.
 * 
 *	@param	_OnHit	This update his called on atk hit
 *
 *	@return		The manialink string
 */
Text UpdateLayerInfo(Boolean _OnHit) {
	declare HP = 0;
	declare AtkLogin = "";
	
	if (Players.existskey(G_AtkPlayerId)) {
		declare Player <=> Players[G_AtkPlayerId];
		HP = Player.Armor / 100;
		AtkLogin = Player.Login;
	}
	if (_OnHit) HP -= 1;
	
	declare CheckpointML = "";
	if (G_CheckpointsNb > 0) {
		declare CheckpointText = "";
		if (G_CheckpointsCapturedNb <= 1) {
			CheckpointText = TextLib::Compose(
				_("Checkpoint captured: %1/%2"),
				TextLib::ToText(G_CheckpointsCapturedNb),
				TextLib::ToText(G_CheckpointsNb)
			);
		} else {
			CheckpointText = TextLib::Compose(
				_("Checkpoints captured: %1/%2"),
				TextLib::ToText(G_CheckpointsCapturedNb),
				TextLib::ToText(G_CheckpointsNb)
			);
		}
		
		CheckpointML = 
			"""<label posn="0 6 1" sizen="80 6" halign="right" valign="bottom" textemboss="1" text="{{{CheckpointText}}}" />""";
	}
	
	declare SpecMapString = TextLib::Compose(
		_("Points to win: %1"),
		TextLib::ToText(S_TurnWin)
	);
	declare SpecPointString = TextLib::Compose(
		_("Points limit: %1"),
		TextLib::ToText(GetPointLimit())
	);
	
	return """
<frame posn="157 88 0" id="Frame_Spectators" >
	<label posn="0 0 1" sizen="80 6" halign="right" style="TextRaceMessage" scale="0.8" text="{{{SpecMapString}}}" />
	<label posn="0 -6 1" sizen="80 6" halign="right" style="TextRaceMessage" scale="0.8" text="{{{SpecPointString}}}" />
</frame>
<frame posn="150 -88 0">
	{{{ CheckpointML }}}
	<label posn="0 0 1" sizen="80 6" halign="right" valign="bottom" textemboss="1" text="{{{TextLib::Compose(_("Attacker Armor Count: %1"), TextLib::ToText(HP))}}}" />
</frame>
<frame posn="160 -90" id="Frame_Atk">
	
</frame>
<script><!--
#Const C_AtkLogin "{{{AtkLogin}}}"
#Const C_AtkClan "{{{G_AtkClan}}}"
#Const C_DefClan "{{{G_DefClan}}}"

main() {
	declare Frame_Spectators <=> (Page.GetFirstChild("Frame_Spectators") as CMlFrame);
	
	declare AtkPlayerId = NullId;
	declare PrevIsSpectatorMode = False;
	
	while (True) {
		sleep(200);
		
		if (!PageIsVisible) continue;
		if (InputPlayer == Null) continue;
		
		foreach (Player in Players) {
			
		}
		
		/*if (PrevIsSpectatorMode != IsSpectatorMode) {
			PrevIsSpectatorMode = IsSpectatorMode;
			if (IsSpectatorMode) {
				Frame_Spectators.Show();
			} else {
				Frame_Spectators.Hide();
			}
		}*/
		
		if (InputPlayer.CurrentClan == 0) {
			Frame_Spectators.Show();
		} else {
			Frame_Spectators.Hide();
		}
	}
}
--></script>""";
}

// ---------------------------------- //
/// Update the Hud3dMarkers.
Void UpdateMarkers() {
	declare CheckpointIndex = 1;
	// Set the marker above the goal
	UIManager.UIAll.Hud3dMarkers = "";
	foreach (Goal in BlockPoles) {
		declare Name = "";
		declare Type = "";
		declare PosX = Goal.Position.X;
		declare PosY = Goal.Position.Y + 25;
		declare PosZ = Goal.Position.Z;
		if (Goal.Tag == "Goal A") {
			Name = "$wA";
			Type = "icon=\"PointA\"";
		} else if (Goal.Tag == "Goal B") {
			Name = "$wB";
			Type = "icon=\"PointB\"";
		} else if (Goal.Tag == "Goal C") {
			Name = "$wC";
			Type = "icon=\"PointC\"";
		} else if (Goal.Tag == "Checkpoint" && Goal.Gauge.Value <= 0) {
			Name = "$w"^CheckpointIndex;
			Type = """label="{{{Name}}}" """;
			CheckpointIndex += 1;
			PosY = Goal.Position.Y + 4;
		}
		
		if (Name == "") continue;
		
		/*UIManager.UIAll.Hud3dMarkers ^= """
			<marker label="{{{Name}}}" pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" />
		""";*/
		UIManager.UIAll.Hud3dMarkers ^= """
			<marker {{{Type}}} pos="{{{PosX}}} {{{PosY}}} {{{PosZ}}}" />
		""";
	}
	
	+++UpdateMarkers+++
}

// ---------------------------------- //
/** Custom Elite stringify for CSmModeEvent
 *
 *	@param	_Name		The name of the stringified object
 *	@param	_Event		The event to stringify
 */
Text EliteStringify(Text _Name, CSmModeEvent _Event) {
	declare JSON = "";
	
	switch (_Event.Type) {
		case CSmModeEvent::EType::OnShoot: {
			JSON = PlayerStringify("Shooter", _Event.Shooter);
		}
		case CSmModeEvent::EType::OnHit: {
			declare HitDist = 0.;
			if (
				_Event.WeaponNum == C_WeaponLaser
				&& _Event.Victim != Null
				&& _Event.Shooter != Null
			) {
				HitDist = MathLib::Distance(_Event.Victim.Position, _Event.Shooter.Position);
			}
			JSON = Json::Merge([
				Json::Stringify("HitDist", HitDist),
				PlayerStringify("Shooter", _Event.Shooter),
				PlayerStringify("Victim", _Event.Victim)
			]);
		}
		case CSmModeEvent::EType::OnArmorEmpty: {
			JSON = Json::Merge([
				PlayerStringify("Shooter", _Event.Shooter),
				PlayerStringify("Victim", _Event.Victim)
			]);
		}
		case CSmModeEvent::EType::OnCapture: {
			declare AtkPlayer <=> CSmPlayer;
			if (Players.existskey(G_AtkPlayerId)) {
				AtkPlayer <=> Players[G_AtkPlayerId];
			}
			JSON = Json::Merge([
				PlayerStringify("Player", AtkPlayer),
				Json::StringifyMinimal("Pole", _Event.BlockPole, "")
			]);
		}
		case CSmModeEvent::EType::OnPlayerRequestRespawn: {
			JSON = PlayerStringify("Player", _Event.Player);
		}
		case CSmModeEvent::EType::OnNearMiss: {
			JSON = Json::Merge([
				PlayerStringify("Shooter", _Event.Shooter),
				PlayerStringify("Victim", _Event.Victim)
			]);
		}
	}
	
	JSON = Json::Merge([
		TurnStringify(),
		Json::StringifyMinimal(_Name, _Event, JSON)
	]);
	
	return JSON;
}

// ---------------------------------- //
/** Simulate an AmorEmptyEvent
 *
 *	@param	_Name		The name of the stringified object
 *	@param	_Event		The event to stringify
 */
Text EliteStringifySimulateArmorEmpty(Text _Name, CSmModeEvent _Event) {
	declare JSON = "";
	
	JSON = Json::Merge([
		PlayerStringify("Shooter", _Event.Shooter),
		PlayerStringify("Victim", _Event.Victim)
	]);
	
	declare EventJSON = "";
	declare More = "";
	if (JSON != "") More = ","^JSON;
	
	if (_Event != Null) {
		EventJSON = """
"{{{_Name}}}":
{
	"Type": "EType::OnArmorEmpty",
	"Damage": {{{_Event.Damage}}},
	"WeaponNum": {{{_Event.WeaponNum}}},
	"MissDist": {{{_Event.MissDist}}}
	{{{More}}}
}
""";
	} else {
		EventJSON = """"{{{_Name}}}": null""";
	}
	
	JSON = Json::Merge([
		TurnStringify(),
		EventJSON
	]);	
	
	return JSON;
}